// Code generated by oto; DO NOT EDIT.

// HeadersFunc allows you to mutate headers for each request.
// Useful for adding authorization into the client.
interface HeadersFunc {
	(headers: HeadersInit);
}

// Client provides access to remote services.
export class Client {
	// basepath is the path prefix for the requests.
	// This may be a path, or an absolute URL.
	public basepath: String = '/oto/'
	// headers allows calling code to mutate the HTTP
	// headers of the underlying HTTP requests.
	public headers?: HeadersFunc
}


export class Service {
	constructor(readonly client: Client) {}
	
		async batchGet(batchGetRequest: BatchGetRequest = null) {
		if (batchGetRequest == null) {
			batchGetRequest = new BatchGetRequest();
		}
		const headers: HeadersInit = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		const response = await fetch(this.client.basepath + 'Service.BatchGet', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(batchGetRequest),
		})
		if (response.status !== 200) {
			throw new Error(`Service.BatchGet: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new BatchGetResponse(json);
		})
	}
	
		async list(listRequest: ListRequest = null) {
		if (listRequest == null) {
			listRequest = new ListRequest();
		}
		const headers: HeadersInit = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		const response = await fetch(this.client.basepath + 'Service.List', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(listRequest),
		})
		if (response.status !== 200) {
			throw new Error(`Service.List: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new ListResponse(json);
		})
	}
	
}



export class BatchGetRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.ids = data.ids;
			
		
		}
	}

		ids: number[];

}

export class Task {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
			
			this.category = data.category;
			
		
			
			this.content = data.content;
			
		
		}
	}

		id: number;

		category: string;

		content: string;

}

export class BatchGetResponse {
	constructor(data?: any) {
		if (data) {
		
			
				
					if (data.tasks) {
						this.tasks = new Array<Task>()
						for (let i = 0; i < data.tasks.length; i++) {
							this.tasks.push(new Task(data.tasks[i]));
						}
					}
				
			
		
			
			this.error = data.error;
			
		
		}
	}

		tasks: Task[];

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string;

}

export class ListRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.category = data.category;
			
		
		}
	}

		category: string;

}

export class ListResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.ids = data.ids;
			
		
			
			this.error = data.error;
			
		
		}
	}

		ids: number[];

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string;

}

